<!DOCTYPE html>
<html>
<header>
    <title>ONNX Runtime JavaScript examples: Quick Start - Web (using bundler)</title>
</header>

<body>
    <!-- consume a single file bundle -->
    <!--script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script-->
    <!--script src="../node_modules/onnxruntime-web/dist/ort.all.js"></script-->
    <script src="./web_dump/dist/ort.all.js"></script>
    <script src="./ort-toolkit/models.js"></script>
    <script src="./ort-toolkit/util.js"></script>
    <!--script type="module" src="protobuf.js"></script-->
    <!--script type="module" src="onnx.js"></script-->
    <!--script src="../test/onnx.dev.js"></script-->
    <!--script type="module" src="onnxdecoder.js"></script-->
    <script type="module">
        // import * as onnxModule from "./onnx.js";
        import * as onnxdecoder from "./onnxdecoder.js";
        const onnxProto = ort.onnxProto.onnx; //onnxModule.onnx;
        const modelName = 'mobilenetv2-12-opt';
        async function getDataFromJsonFile(name) {
            // TODO: Fix constant node file not found.
            const response = await fetch(`./modeldata/${modelName}/` + name + ".json");
            const json = await response.json();
            if (json.type === 'float') {
                json.type = 'float32';
            }
            return json;
        }

        async function generateGraphPlan(node) {
            const nodePlan = { name: node.name };
            nodePlan.inputs = [];
            nodePlan.outputs = [];
            const inputShapeDefinitions = [];
            console.log('node name:' + node.name);
            try {
                for (const inputName of node.inputNames) {
                    nodePlan.inputs.push(await getDataFromJsonFile(inputName));
                }
             } catch (e) {
                throw ("Not find input: " + node.name + ", "+ JSON.stringify(node));
             } 

            try {
                for (const outputName of node.outputNames) {
                    nodePlan.outputs.push(await getDataFromJsonFile(outputName));
                }
             } catch (e) {
                throw ("Not find output: " + node.name + ", "+ JSON.stringify(node));
             } 

            for (const input of nodePlan['inputs'])
                inputShapeDefinitions.push((input['dims']));
            console.log(inputShapeDefinitions);
            const attributs = [];
            node.attributes._attributes.forEach((value, key)=>{
                    console.log(key + ", " + value);
                    attributs.push({'name': key, 'data': value[0], 'type': value[1]});
                }
            );
            let domain = {"domain":"com.microsoft","version":1};
            if (node.name=== 'Conv_4' || node.name=== 'Conv_9'|| node.name=== 'Conv_14') {
                domain = { "domain": "", "version": 12 };

            }
            const graphPlan = {
                "name": "This is comment " + node.opType,
                "operator": node.opType,
                "attributes": attributs,
                "inputShapeDefinitions": inputShapeDefinitions,
                "cases": [
                    nodePlan,
                ],
                "backend": "cpu",
                // "opset": { "domain": "", "version": 12 }
                "opset": domain,
                //"opset": [{"domain":"","version":12},{"domain":"com.microsoft.nchwc","version":1},{"domain":"ai.onnx.ml","version":3},{"domain":"com.ms.internal.nhwc","version":19},{"domain":"ai.onnx.training","version":1},{"domain":"ai.onnx.preview.training","version":1},{"domain":"com.microsoft","version":1},{"domain":"com.microsoft.experimental","version":1},{"domain":"org.pytorch.aten","version":1}]
            };

            return graphPlan;
        }

        async function runGraphPlan(graphPlan) {
            ort.env.debug = true
            ort.env.logLevel = 'verbose';

            const model = onnxProto.ModelProto.create();
            model.irVersion = onnxProto.Version.IR_VERSION;
            // model.opsetImport.push(opsetImport);
            model.opsetImport =   [{"domain":"","version":12},
                        {"domain":"com.microsoft.nchwc","version":1},{"domain":"ai.onnx.ml","version":3},
                        {"domain":"com.ms.internal.nhwc","version":19},{"domain":"ai.onnx.training","version":1},
                        {"domain":"ai.onnx.preview.training","version":1},
                        {"domain":"com.microsoft","version":1},{"domain":"com.microsoft.experimental","version":1},{"domain":"org.pytorch.aten","version":1}];
            model.graph = onnxProto.GraphProto.create();

            const case0 = graphPlan["cases"][0];
            // console.log('case0 : ' + JSON.stringify(case0));
            // TODO: outputs maybe array.
            const session = (await onnxdecoder.createOnnxModel(graphPlan, onnxProto));
            const result = await onnxdecoder.runProtoOpTestcase(session, case0);
            return result;
        }

        async function loadModel(arg, byteOffset, length) {
            // const model = new onnx.Model();
            const model = new ort.Model();
            if (typeof arg === 'string') {
                const isOrtFormat = arg.endsWith('.ort');
                if (typeof process !== 'undefined' && process.versions && process.versions.node) {
                    // node
                    const buf = await readFile(arg);
                    model.load(buf);
                } else {
                    // browser
                    const response = await fetch(arg);
                    const buf = await response.arrayBuffer();
                    model.load(new Uint8Array(buf));
                }
            } else if (!ArrayBuffer.isView(arg)) {
                // load model from ArrayBuffer
                const arr = new Uint8Array(arg, byteOffset || 0, length || arg.byteLength);
                //this.initialize(arr);
                model.load(arr);
            } else {
                model.load(arg);
            }
            return model;
        }

        async function generateDumpData() {
            const session = await ort.InferenceSession.create(`./ort-models/${modelName}.onnx`);
            // prepare inputs. a tensor need its corresponding TypedArray as data
            const dataA = Float32Array.from([1, 2, 3]);
            const dataB = Float32Array.from([10, 20, 30]);
            const tensorA = new ort.Tensor('float32', dataA, [3]);
            const tensorB = new ort.Tensor('float32', dataB, [3]);
            // prepare feeds. use model input names as keys.
            const feeds = { a: tensorA, b: tensorB };

            // feed inputs and run
            const results = await session.run(feeds);

            // read from results
            const dataC = results.output2.data;
            console.log(dataC);
        }

        async function compareSingleNode(node) {
            if (node['name'] === 'n1') {
                    //continue;
                }
                const graphPlan = await generateGraphPlan(node);
                for (const input of graphPlan["cases"][0]['inputs'])
                    console.log(input['dims'])
                for (const output of graphPlan["cases"][0]['outputs'])
                    console.log(output['dims'])
                const result1 = await runGraphPlan(graphPlan);
                const result = Array.from(result1.output_0.cpuData);
                const reference = graphPlan["cases"][0]['outputs'];
                console.log("CMP reference : " + JSON.stringify(reference[0].data[0]));
                console.log("CMP result : " + JSON.stringify(result[0]));
                const compareResult = compare(reference[0].data, result);
                console.log("compareResult="+ compareResult);
        }

        async function main() {
            // Step 1: generate dump data files.
            // await generateDumpData();
            // Step 2: get node list, then run and compare. 
            const model = await loadModel(`./ort-models/${modelName}.onnx`);
            const nodes = model.graph._nodes;
            for (const node of nodes) {
                if (node.name === 'Conv_14') {
                    console.log(node);
                    await compareSingleNode(node);
                }
            }
        }
        main();
    </script>
</body>

</html>
